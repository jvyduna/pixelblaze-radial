{
  "name": "Fireworks",
  "id": "tLuTtKcZu3WaHD6ig",
  "sources": {
    "main": "/* Also mapped. 12 * 144 of SK9822 wired in setions as:\n        0\n     5     x\n   x         1\n  4           x\n   x         2\n    3      x\n        x\n*/\n\nvar arms = 12\nvar pixPerArm = pixelCount / arms\nradials = array(arms)\nfor (i = 0; i < arms; i ++) { radials[i] = array(pixPerArm) } \n\n// Arm remap array -> takes physical segment in index order (wired order)\n// and returns the index of segment where 0 is the straight up arm (12 oo clock)\n// and proceeds clockwise. aRa[chunk] = clockPositionHour\nvar aRa = array(arms);\naRa[0] = 0; aRa[1] = 6; aRa[2] = 2; aRa[3] = 8;\naRa[4] = 4; aRa[5] = 10; aRa[6] = 7; aRa[7] = 1; \naRa[8] = 9; aRa[9] = 3; aRa[10] = 11; aRa[11] = 5; \nfunction indexToRadial(index) {\n  segment = floor(index / pixPerArm)\n  return aRa[segment]\n}\n\n// 0, 1/12, 2/12, ..etc.. 11/12 \nfunction indexToUnitRadial(index) {\n  return indexToRadial(index) / arms\n}\n\n// Takes an index, returns the fraction of an arm's length from center\nfunction indexToUnit(index) {\n  arm = floor(index / pixPerArm)\n  inbound = (arm % 2) == 0\n  pixIntoArm = index % pixPerArm\n  pixFromCenter = inbound ? (pixPerArm - pixIntoArm - 1) : pixIntoArm\n  return pixFromCenter / pixPerArm\n}\n\n\nvar t1Override\nexport function slidert1Override(v) { t1Override = v }\nvar modeOverride\nexport function sliderModeOverride(v) { modeOverride = floor(v * numModes * 0.999) }\nvar dmOverride\nexport function sliderDMOverride(v) { dmOverride = floor(v * numDecayModes) }\n\nvar numModes = 8\nvar modeSetup = array(numModes)\nvar beforeRenders = array(numModes)\nvar hFns = array(numModes)\nvar sFns = array(numModes)\nvar vFns = array(numModes)\n\n\ncolorBox = array(4)\n\n\nvar t1, linearT1, dMode = 0\nvar speed, thisModePeriod = 1, thisModeMs = 0\nvar width1 = 5, c1 = 0, sparkle1 = 0\nexport var mode = 0\nexport var w, w1, w2\nexport function beforeRender(delta) {\n  thisModeMs += delta\n  t1 = thisModeMs / (thisModePeriod * 1000)\n\n  if (t1 >= 1) { newMode() }\n  // t1 = t1Override\n  // dMode = dmOverride\n  linearT1 = t1\n  t1 = decayModes[dMode](t1)\n  et1 = 2 * t1 - 0.5 // \"Extended\" t1 - helps create smooth ends and space between modes\n  beforeRenders[mode](delta)\n}\n\nfunction newMode() {\n  mode = floor(random(numModes))\n  if (modeOverride > 0) { mode = modeOverride } // Mode slider leftmost == auto\n  dMode =  floor(random(numDecayModes))\n  thisModeMs = 0\n  t1 = 0\n  thisModePeriod = 1 + random(10)\n  \n  modeSetup[mode]()\n}\n\nexport function render(index) {\n  h = hFns[mode](index)\n  s = sFns[mode](index)\n  v = vFns[mode](index)\n  hsv(h, s, v)\n}\n\n\nvar numDecayModes = 3\nvar decayModes = array(numDecayModes)\ndecayModes[0] = (u) => { return 1 - (1/pow((1 + u), 5)) } // Power\ndecayModes[1] = (u) => { return 1 - exp(-3 * u) } // Exponential\ndecayModes[2] = (u) => { return u } // Linear\n\n\n// The actual modes\n\nmodeSetup[0] = () => { }\nbeforeRenders[0] = (delta) => { }\nhFns[0] = (index) => { return t1 + index/pixelCount }\nsFns[0] = (index) => { return 1 }\nvFns[0] = (index) => { return abs(indexToUnit(index) - t1) < 1 / (pixelCount / arms) }\n\n\nmodeSetup[1] = () => { \n  c1 = random(0.03) - 0.01\n  width1 = random(1) // 0..1 units, applied to pixPerArm\n  sparkle1 = floor(random(2))\n}\nbeforeRenders[1] = (delta) => { }\nhFns[1] = (index) => { return c1 }\nsFns[1] = (index) => { return 1 }\nvFns[1] = (index) => { \n  v = 1 - abs(et1 - indexToUnit(index)) / width1\n  v = clamp(v, 0, 1)\n  if (sparkle1 && random(t1) > 0.5) v = 0\n  return v * v\n}\n\n\nmodeSetup[2] = () => { thisModePeriod = 1 + random(3) }\nbeforeRenders[2] = (delta) => { }\nhFns[2] = (index) => { return 0 }\nsFns[2] = (index) => { return 0 }\nvFns[2] = (index) => { return t1 < 0.33 ? square(t1*30,1-3*t1) : 0 }\n\n\nvar gamma1 = 1\nmodeSetup[3] = () => { gamma1 = 1 + floor(random(6)) }\nbeforeRenders[3] = (delta) => { }\nhFns[3] = (index) => { return t1 + index/pixelCount }\nsFns[3] = (index) => { return 1 }\nvFns[3] = (index) => { v = triangle(t1); return pow(v, gamma1) }\n\n\n// Peony\nmodeSetup[4] = () => { \n  colorBox[0] = 0\n  colorBox[1] = 0.02\n  colorBox[2] = 0.7\n  colorBox[3] = random(1)\n  color1 = colorBox[floor(random(4))]\n}\nbeforeRenders[4] = (delta) => { }\nhFns[4] = (index) => { return color1 + random(0.02) }\nsFns[4] = (index) => { return (random(1) < (2 * t1 - 1) && random(1) < 0.02) ? 0 : 1 }\nvFns[4] = (index) => { \n  fadeEnd = clamp(-1/(0.2)*(linearT1-0.8) + 1,0,1);\n  return fadeEnd * (indexToUnit(index) < (t1*1.2)) }\n\n\n// Fill whole strip linearly\nvar startingOffset = 0\nmodeSetup[5] = () => { \n  colorBox[0] = 0.33\n  colorBox[1] = 0.13\n  colorBox[2] = 0.66\n  colorBox[3] = 0.96\n  color1 = colorBox[floor(random(4))]\n  startingOffset = floor(random(pixelCount))\n}\nbeforeRenders[5] = (delta) => { }\nhFns[5] = (index) => { return color1 + random(0.02) }\nsFns[5] = (index) => { return sqrt((t1)) }\nvFns[5] = (index) => { \n  progressOutwards = ((index + startingOffset ) % pixelCount)/pixelCount < t1\n  fadeEnd = clamp(-1/(0.2)*(linearT1-0.8) + 1,0,1)\n  return progressOutwards * fadeEnd\n}\n\n\n// Radials on delays\nmodeSetup[6] = () => { width1 = 0.3 }\nbeforeRenders[6] = (delta) => { }\nhFns[6] = (index) => { return color1 + t1 + indexToUnitRadial(index) }\nsFns[6] = (index) => { return 1 }\nvFns[6] = (index) => { \n  v = 1 - abs(et1 - indexToUnitRadial(index) - indexToUnit(index)) / width1\n  v = clamp(v, 0, 1)\n  fadeEnd = clamp(-1/(0.2)*(linearT1-0.8) + 1,0,1)\n  v *= fadeEnd\n  return v\n}\n\n\n// Wave phase offsets\nexport var colorMode = 0\nmodeSetup[7] = () => {\n  colorMode = floor(random(4))\n  width1 = random(30)\n  colorBox[0] = (i) => { return indexToUnitRadial(i) }\n  colorBox[1] = (i) => { return 0.2 * i/pixelCount }\n  colorBox[2] = (i) => { return 0 }\n  colorBox[3] = (i) => { return 0 + random(0.02) }\n}\nbeforeRenders[7] = (delta) => { }\nhFns[7] = (index) => { return colorBox[colorMode](index) }\nsFns[7] = (index) => { return 1 }\nvFns[7] = (index) => { \n  pos = indexToUnit(index)\n  radial = indexToUnitRadial(index)\n  v = triangle((pos - t1 + linearT1)*4) * triangle(pos - t1 * (width1 - 4))\n  v = clamp(v, 0, 1)\n  \n  fadeEnd = clamp(-1/(0.2)*(linearT1-0.8) + 1,0,1)\n  v *= fadeEnd\n  return v * v\n}\n\n"
  },
  "preview": "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"
}