{
  "name": "radial Pew-Pew-Pew!",
  "id": "Rfr42C7CMANgoD93J",
  "sources": {
    "main": "/* Also mapped. 12 * 144 of SK9822 wired in setions as:\n        0\n     5     x\n   x         1\n  4           x\n   x         2\n    3      x\n        x\n*/\n\nvar arms = 12\nvar pixPerArm = pixPerRadial = pixelCount / arms\nradials = array(arms)\nfor (i = 0; i < arms; i ++) { radials[i] = array(pixPerArm) } \n\n// Arm remap array -> takes physical segment in index order (wired order)\n// and returns the index of segment where 0 is the straight up arm (12 oo clock)\n// and proceeds clockwise. aRa[chunk] = clockPositionHour\nvar aRa = array(arms);\naRa[0] = 0; aRa[1] = 6; aRa[2] = 2; aRa[3] = 8;\naRa[4] = 4; aRa[5] = 10; aRa[6] = 7; aRa[7] = 1; \naRa[8] = 9; aRa[9] = 3; aRa[10] = 11; aRa[11] = 5; \nfunction indexToRadial(index) {\n  segment = floor(index / pixPerArm)\n  return aRa[segment]\n}\n\n// 0, 1/12, 2/12, ..etc.. 11/12 \nfunction indexToUnitRadial(index) {\n  return indexToRadial(index) / arms\n}\n\n// Takes an index, returns # pixels from center\nfunction indexFromCenter(index) {\n  arm = floor(index / pixPerArm)\n  inbound = (arm % 2) == 0\n  pixIntoArm = index % pixPerArm\n  pixFromCenter = inbound ? (pixPerArm - pixIntoArm - 1) : pixIntoArm\n  return pixFromCenter\n}\n\nvar radialIndex = array(pixelCount)\nfor (i = 0; i < pixelCount; i++) { radialIndex[i] = indexFromCenter(i) }\n\n\n// Takes an index, returns a fraction of an arm's length from center\nfunction indexToUnit(index) {\n  return radialIndex[index] / pixPerArm\n}\n\nvar radialPct = array(pixelCount)\nfor (i = 0; i < pixelCount; i++) { radialPct[i] = indexToUnit(i) }\n\n\n// Pew-Pew-Pew! v2.0.0 (Pattern for PixelBlaze)\n// by Scott Balay -- https://github.com/zenblender\n\nisForwardDirection = true // flip to run backwards\nlaserCount = 5  // use a multiple of numPaletteRGBs to have each available color represented equally\nfadeFactor = 0.8\nspeedFactor = 0.01\n\n// when on, new lasers cause entire strip to flash blue\n// when off, blue component of each laser affects its color as normal\nuseBlueLightning = 1\n\n// init RGBs that in the palette of available colors:\nnumPaletteRGBs = 5\npaletteRGBs = array(numPaletteRGBs)\npaletteRGBs[0] = packRGB(255,13,107)\npaletteRGBs[1] = packRGB(232,12,208)\npaletteRGBs[2] = packRGB(200,0,255)\npaletteRGBs[3] = packRGB(124,12,232)\npaletteRGBs[4] = packRGB(70,13,255)\n\nambientR = 15\nambientG = 0\nambientB = 0\n\nfunction getRandomVelocity() { return random(1) + 0.5 }\n\n// init RGB of each laser:\nexport var laserRGBs = createArray(laserCount, function(i){ return paletteRGBs[i % numPaletteRGBs] }, true)\n\n// init randomized starting positions of each laser:\nlaserPositions = createArray(laserCount, function(){ return random(pixPerArm) }, true)\n\n// init each laser's velocity\nlaserVelocities = createArray(laserCount, function(){ return getRandomVelocity() }, true)\n\n// init the full pixel array:\npixelRGBs = createArray(pixPerArm)\n\nexport function beforeRender(delta) {\n  // fade existing pixels:\n  for (pixelIndex = 0; pixelIndex < pixPerArm; pixelIndex++) {\n    pixelRGBs[pixelIndex] = packRGB(\n      floor(getR(pixelRGBs[pixelIndex]) * fadeFactor),\n      floor(getG(pixelRGBs[pixelIndex]) * fadeFactor),\n      floor(getB(pixelRGBs[pixelIndex]) * fadeFactor)\n    )\n  }\n\n  // advance laser positions:\n  for (laserIndex = 0; laserIndex < laserCount; laserIndex++) {\n    currentLaserPosition = laserPositions[laserIndex]\n    nextLaserPosition = currentLaserPosition + (delta * speedFactor * laserVelocities[laserIndex])\n    for (pixelIndex = floor(nextLaserPosition); pixelIndex >= currentLaserPosition; pixelIndex--) {\n      // draw new laser edge, but fill in \"gaps\" from last draw:\n      if (pixelIndex < pixPerArm) {\n        pixelRGBs[pixelIndex] = packRGB(\n            min(255, getR(pixelRGBs[pixelIndex]) + getR(laserRGBs[laserIndex])),\n            min(255, getG(pixelRGBs[pixelIndex]) + getG(laserRGBs[laserIndex])),\n            min(255, getB(pixelRGBs[pixelIndex]) + getB(laserRGBs[laserIndex]))\n        )\n      }\n    }\n\n    laserPositions[laserIndex] = nextLaserPosition\n    if (laserPositions[laserIndex] >= pixPerArm) {\n      // wrap this laser back to the start\n      laserPositions[laserIndex] = 0\n      laserVelocities[laserIndex] = getRandomVelocity()\n    }\n  }\n}\n\nexport function render(rawIndex) {\n  index = radialIndex[rawIndex]\n\n  index = isForwardDirection ? index : (pixPerArm - index - 1)\n  rgb(\n    clamp((getR(pixelRGBs[index]) + ambientR) / 255, 0, 1),\n    clamp((getG(pixelRGBs[index]) + ambientG) / 255, 0, 1),\n    clamp((getB(pixelRGBs[useBlueLightning ? 0 : index]) + ambientB) / 255, 0, 1)\n  )\n}\n\n//===== UTILS =====\n// ARRAY INIT FUNCTIONS:\nfunction createArray(size, valueOrFn, isFn) {\n  arr = array(size)\n  if (!valueOrFn) return arr\n  for (i = 0; i < size; i++) {\n    arr[i] = isFn ? valueOrFn(i) : valueOrFn\n  }\n  return arr\n}\n// RGB FUNCTIONS:\n// assume each component is an 8-bit \"int\" (0-255)\nfunction packRGB(r, g, b) { return _packColor(r, g, b) }\nfunction getR(value) { return _getFirstComponent(value) }\nfunction getG(value) { return _getSecondComponent(value) }\nfunction getB(value) { return _getThirdComponent(value) }\n// HSV FUNCTIONS:\n// assume each component is an 8-bit \"int\" (0-255)\nfunction packHSV(h, s, v) { return _packColor(h, s, v) }\nfunction getH(value) { return _getFirstComponent(value) }\nfunction getS(value) { return _getSecondComponent(value) }\nfunction getV(value) { return _getThirdComponent(value) }\n// \"PRIVATE\" COLOR FUNCTIONS:\n// assume each component is an 8-bit \"int\" (0-255)\nfunction _packColor(a, b, c) { return (a<<8) + b + (c>>8) }\nfunction _getFirstComponent(value) { return (value>>8) & 0xff } // R or H\nfunction _getSecondComponent(value) { return value & 0xff } // G or S\nfunction _getThirdComponent(value) { return (value<<8) & 0xff } // B or V\n"
  },
  "preview": "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"
}