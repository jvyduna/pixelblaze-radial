{
  "name": "radial sound - blinkfade",
  "id": "qEKGgN4vJeESmjZsN",
  "sources": {
    "main": "/* Also mapped. 12 * 144 of SK9822 wired in setions as:\n        0\n     5     x\n   x         1\n  4           x\n   x         2\n    3      x\n        x\n*/\n\nvar arms = 12\nvar pixPerArm = pixPerRadial = pixelCount / arms\nradials = array(arms)\nfor (i = 0; i < arms; i ++) { radials[i] = array(pixPerArm) } \n\n// Arm remap array -> takes physical segment in index order (wired order)\n// and returns the index of segment where 0 is the straight up arm (12 oo clock)\n// and proceeds clockwise. aRa[chunk] = clockPositionHour\nvar aRa = array(arms);\naRa[0] = 0; aRa[1] = 6; aRa[2] = 2; aRa[3] = 8;\naRa[4] = 4; aRa[5] = 10; aRa[6] = 7; aRa[7] = 1; \naRa[8] = 9; aRa[9] = 3; aRa[10] = 11; aRa[11] = 5; \nfunction indexToRadial(index) {\n  segment = floor(index / pixPerArm)\n  return aRa[segment]\n}\n\n// 0, 1/12, 2/12, ..etc.. 11/12 \nfunction indexToUnitRadial(index) {\n  return indexToRadial(index) / arms\n}\n\n// Takes an index, returns # pixels from center\nfunction indexFromCenter(index) {\n  arm = floor(index / pixPerArm)\n  inbound = (arm % 2) == 0\n  pixIntoArm = index % pixPerArm\n  pixFromCenter = inbound ? (pixPerArm - pixIntoArm - 1) : pixIntoArm\n  return pixFromCenter\n}\n\nvar radialIndex = array(pixelCount)\nfor (i = 0; i < pixelCount; i++) { radialIndex[i] = indexFromCenter(i) }\n\n\n// Takes an index, returns a fraction of an arm's length from center\nfunction indexToUnit(index) {\n  return radialIndex[index] / pixPerArm\n}\n\nvar radialPct = array(pixelCount)\nfor (i = 0; i < pixelCount; i++) { radialPct[i] = indexToUnit(i) }\n\n\n//This pattern uses the sensor expansion board\n\nexport var energyAverage\nexport var maxFrequency\n\ntargetFill = 0.2\n\nvals = array(pixPerArm)\nhues = array(pixPerArm)\nbrightnessFeedback = 0\npic = makePIController(.05, .15, 300, 0, 1000)\nsensitivity = 0\n\n// Makes a new PI Controller\nfunction makePIController(kp, ki, start, min, max) {\n  var pic = array(5)\n  pic[0] = kp\n  pic[1] = ki\n  pic[2] = start\n  pic[3] = min\n  pic[4] = max\n  return pic\n}\n\nfunction calcPIController(pic, err) {\n  pic[2] = clamp(pic[2] + err, pic[3], pic[4])\n  return max(pic[0] * err + pic[1] * pic[2],.3)\n}\n\nexport function beforeRender(delta) {\n  sensitivity = calcPIController(pic, targetFill - brightnessFeedback / pixPerArm);\n  brightnessFeedback = 0\n  for (i = 0; i < pixPerArm; i++) {\n    vals[i] -= .005 * delta * .1 + abs(energyAverage * sensitivity / 5000)\n    if (vals[i] <= 0) {\n      vals[i] = energyAverage * sensitivity * random(1)\n      hues[i] = time(.07) + triangle(maxFrequency / 1000) * .2\n    }\n  }\n}\n\nexport function render(index) {\n  index = radialIndex[index]\n  v = vals[index] * 3\n  v = v * v\n  brightnessFeedback += clamp(v, 0, 1)\n  hsv(hues[index], 1, v)\n}\n"
  },
  "preview": "/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAMCAgMCAgMDAwMEAwMEBQgFBQQEBQoHBwYIDAoMDAsKCwsNDhIQDQ4RDgsLEBYQERMUFRUVDA8XGBYUGBIUFRT/2wBDAQMEBAUEBQkFBQkUDQsNFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT/wAARCACWAGQDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAn/xAAaEAEAAgMBAAAAAAAAAAAAAAAAEUEBITGR/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhEDEQA/AJVAAAAAAAAAAAAAAFAAAAdAAiMTr0AKKACJxOvQAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/9k="
}