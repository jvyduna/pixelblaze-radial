{
  "name": "radial sound - spectro kalidastrip",
  "id": "TQMWygxoH8bnpZMWf",
  "sources": {
    "main": "/* Also mapped. 12 * 144 of SK9822 wired in setions as:\n        0\n     5     x\n   x         1\n  4           x\n   x         2\n    3      x\n        x\n*/\n\nvar arms = 12\nvar pixPerArm = pixPerRadial = pixelCount / arms\nradials = array(arms)\nfor (i = 0; i < arms; i ++) { radials[i] = array(pixPerArm) } \n\n// Arm remap array -> takes physical segment in index order (wired order)\n// and returns the index of segment where 0 is the straight up arm (12 oo clock)\n// and proceeds clockwise. aRa[chunk] = clockPositionHour\nvar aRa = array(arms);\naRa[0] = 0; aRa[1] = 6; aRa[2] = 2; aRa[3] = 8;\naRa[4] = 4; aRa[5] = 10; aRa[6] = 7; aRa[7] = 1; \naRa[8] = 9; aRa[9] = 3; aRa[10] = 11; aRa[11] = 5; \nfunction indexToRadial(index) {\n  segment = floor(index / pixPerArm)\n  return aRa[segment]\n}\n\n// 0, 1/12, 2/12, ..etc.. 11/12 \nfunction indexToUnitRadial(index) {\n  return indexToRadial(index) / arms\n}\n\n// Takes an index, returns # pixels from center\nfunction indexFromCenter(index) {\n  arm = floor(index / pixPerArm)\n  inbound = (arm % 2) == 0\n  pixIntoArm = index % pixPerArm\n  pixFromCenter = inbound ? (pixPerArm - pixIntoArm - 1) : pixIntoArm\n  return pixFromCenter\n}\n\nvar radialIndex = array(pixelCount)\nfor (i = 0; i < pixelCount; i++) { radialIndex[i] = indexFromCenter(i) }\n\n\n// Takes an index, returns a fraction of an arm's length from center\nfunction indexToUnit(index) {\n  return radialIndex[index] / pixPerArm\n}\n\nvar radialPct = array(pixelCount)\nfor (i = 0; i < pixelCount; i++) { radialPct[i] = indexToUnit(i) }\n\n\n\n\n//This pattern uses the sensor expansion board\nexport var frequencyData\n\naverageWindowMs = 1500\nspeed = .03\ntargetFill = .2\n\nbrightnessFeedback = 0\naverages = array(32)\npixels = array(pixPerArm)\npic = makePIController(.2, .15, 30, 0, 400)\n\n// Makes a new PI Controller\nfunction makePIController(kp, ki, start, min, max) {\n  var pic = array(5)\n  pic[0] = kp\n  pic[1] = ki\n  pic[2] = start\n  pic[3] = min\n  pic[4] = max\n  return pic\n}\n\nfunction calcPIController(pic, err) {\n  pic[2] = clamp(pic[2] + err, pic[3], pic[4])\n  return max(pic[0] * err + pic[1] * pic[2],.3)\n}\n\nexport function beforeRender(delta) {\n  sensitivity = calcPIController(pic, targetFill - brightnessFeedback / pixPerArm);\n  brightnessFeedback = 0\n  t1 = time(speed)\n  dw = delta / averageWindowMs\n  for (i = 0; i < 32; i++) {\n    averages[i] = max(.0001, averages[i] * (1 - dw) + frequencyData[i] * dw * sensitivity)\n  }\n}\n\n//interpolates values between indexes in an array\nfunction arrayLerp(a, i) {\n  var ifloor, iceil, ratio\n  ifloor = floor(i)\n  iceil = ceil(i);\n  ratio = i - ifloor;\n  return a[ifloor] * (1 - ratio) + a[iceil] * ratio\n}\n\nexport function render(index) {\n  index = radialIndex[index]\n  pct = radialPct[index]\n\n  var x, y, i, h, s, v\n\n  //i = (index*31/pixelCount + wave(t1*2)*31) % 31\n  i = triangle(triangle(pct *2) + t1 ) * 31\n  // i = triangle((index + pixelCount/2)/pixelCount)*31\n  // i = index*31/pixelCount\n\n\n  v = (arrayLerp(frequencyData, i) * 4 - arrayLerp(averages, i)) * sensitivity * (arrayLerp(averages, i) * 1000 + .5)\n  h = i / 31 + pct / 4\n  v = v > 0 ? v * v : 0\n  s = 2 - v\n  pixels[index] = pixels[index] * .75 + v\n  v = pixels[index]\n  \n  brightnessFeedback += clamp(v, 0, 2)\n  hsv(h, s, min(v, 1))\n}"
  },
  "preview": "/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAMCAgMCAgMDAwMEAwMEBQgFBQQEBQoHBwYIDAoMDAsKCwsNDhIQDQ4RDgsLEBYQERMUFRUVDA8XGBYUGBIUFRT/2wBDAQMEBAUEBQkFBQkUDQsNFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT/wAARCACWAGQDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAn/xAAUEAEAAAAAAAAAAAAAAAAAAAAA/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhEDEQA/AJVAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//9k="
}