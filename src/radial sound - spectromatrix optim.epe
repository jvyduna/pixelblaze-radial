{
  "name": "radial sound - spectromatrix optim",
  "id": "vXGvYT7tqJCsCKfiD",
  "sources": {
    "main": "/* Also mapped. 12 * 144 of SK9822 wired in setions as:\n        0\n     5     x\n   x         1\n  4           x\n   x         2\n    3      x\n        x\n*/\n\nvar arms = 12\nvar pixPerArm = pixPerRadial = pixelCount / arms\nradials = array(arms)\nfor (i = 0; i < arms; i ++) { radials[i] = array(pixPerArm) } \n\n// Arm remap array -> takes physical segment in index order (wired order)\n// and returns the index of segment where 0 is the straight up arm (12 oo clock)\n// and proceeds clockwise. aRa[chunk] = clockPositionHour\nvar aRa = array(arms);\naRa[0] = 0; aRa[1] = 6; aRa[2] = 2; aRa[3] = 8;\naRa[4] = 4; aRa[5] = 10; aRa[6] = 7; aRa[7] = 1; \naRa[8] = 9; aRa[9] = 3; aRa[10] = 11; aRa[11] = 5; \nfunction indexToRadial(index) {\n  segment = floor(index / pixPerArm)\n  return aRa[segment]\n}\n\n// 0, 1/12, 2/12, ..etc.. 11/12 \nfunction indexToUnitRadial(index) {\n  return indexToRadial(index) / arms\n}\n\n// Takes an index, returns # pixels from center\nfunction indexFromCenter(index) {\n  arm = floor(index / pixPerArm)\n  inbound = (arm % 2) == 0\n  pixIntoArm = index % pixPerArm\n  pixFromCenter = inbound ? (pixPerArm - pixIntoArm - 1) : pixIntoArm\n  return pixFromCenter\n}\n\nvar radialIndex = array(pixelCount)\nfor (i = 0; i < pixelCount; i++) { radialIndex[i] = indexFromCenter(i) }\n\n\n// Takes an index, returns a fraction of an arm's length from center\nfunction indexToUnit(index) {\n  return radialIndex[index] / pixPerArm\n}\n\nvar radialPct = array(pixelCount)\nfor (i = 0; i < pixelCount; i++) { radialPct[i] = indexToUnit(i) }\n\n\n\n\n//This pattern uses the sensor expansion board\n//it supports pixel mapped configurations with 2D or 3D maps\nexport var frequencyData\n\nwidth = 14\nzigzag = true\n\naverageWindowMs =500\n\nfade = .6\nspeed = 1\nzoom = .3\ntargetFill = 0.15\nvar pic = makePIController(1, .1, 300, 0, 300)\n\nvar sensitivity = 0\nbrightnessFeedback = 0\nvar averages = array(32)\npixels = array(pixPerArm)\nvals = array(32)\n\n// Makes a new PI Controller\nfunction makePIController(kp, ki, start, min, max) {\n  var pic = array(5)\n  pic[0] = kp\n  pic[1] = ki\n  pic[2] = start\n  pic[3] = min\n  pic[4] = max\n  return pic\n}\n\nfunction calcPIController(pic, err) {\n  pic[2] = clamp(pic[2] + err, pic[3], pic[4])\n  return max(pic[0] * err + pic[1] * pic[2],.3)\n}\n\nexport function beforeRender(delta) {\n  t1 = time(1)\n  t2 = time(.6)\n  \n  wt1 = wave(t1 * speed)\n\n  sensitivity = calcPIController(pic, targetFill - brightnessFeedback / pixPerArm);\n  brightnessFeedback = 0\n  \n  dw = delta / averageWindowMs\n  for (i = 0; i < 32; i++) {\n    averages[i] = max(.00001, averages[i] * (1 - dw) + frequencyData[i] * dw * sensitivity)\n    vals[i] = (frequencyData[i] * sensitivity - averages[i]*2) * 10 * (averages[i] * 1000 + 1)\n  }\n\n}\n\n\nexport function render3D(index, x, y, z) {\n  index = radialIndex[index]\n\n  var  i, h, s, v\n  \n  i = triangle((wave((x+z)*zoom + wt1) + wave((y+z)*zoom - wt1)) *.5 + t2) * 31\n\n  v = vals[i]\n\n  h = i / 60 + t1 \n  v = v > 0 ? v*v : 0\n  s = 1 - v\n  pixels[index] = pixels[index] * fade + v\n  v = pixels[index];\n\n  brightnessFeedback += clamp(v, 0, 2)\n  hsv(h, s, v)\n}\n\n//support 2D pixel mapped configurations\nexport function render2D(index, x, y) {\n  render3D(index, x, y, 0)\n}\n\n//this pixel mapper shim will work without a pixel map or on older Pixelblazes\n//it calculates x/y based on a 2D LED matrix display given a known width and height\nexport function render(index) {\n  var width = 8, height = 8\n  var y = floor(index / width)\n  var x = index % width\n  //comment out this next line if you don't have zigzag wiring:\n  x = (y % 2 == 0 ? x : width - 1 - x)\n  x /= width\n  y /= height\n  render2D(index, x, y)\n}\n"
  },
  "preview": "/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAMCAgMCAgMDAwMEAwMEBQgFBQQEBQoHBwYIDAoMDAsKCwsNDhIQDQ4RDgsLEBYQERMUFRUVDA8XGBYUGBIUFRT/2wBDAQMEBAUEBQkFBQkUDQsNFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT/wAARCACWAGQDASIAAhEBAxEB/8QAGgABAQEBAQEBAAAAAAAAAAAAAAIBAwQFCf/EADUQAAICAAMGAwYDCQAAAAAAAAABAhEDEiExUmFxkeEEE0EiUYGhsdEFI2IVMjM0QnKCwtL/xAAXAQEBAQEAAAAAAAAAAAAAAAAAAQID/8QAIBEBAAIBBAIDAAAAAAAAAAAAAAERMQISIUFRYQOR8P/aAAwDAQACEQMRAD8A/KoqGTXNm4USAsTQ9peHKcmlGUvgyARYmpeieeKcnnpfrIhc1cp6p7JMlKWWvZr4GPKtKd8zNO06ubdVJyUlCLk/XbX1MnlSWfzVzOUZJXcVLnZj1fuFJPycPQm4QpYblB8dfkbBRmlCWC03SUsyilzbWw4x8zLazZferoxqbim1KlsslLOu4w9MvDYuCk4YamkvaeHiLErnl2fE+hg/iMPA4bU8HGwnL91Sw4pc9Ej4i2noxfLlhRcZYUa1eHDPb66GNWjdxqc91vVajOa8JDxUsG9uFNpXX9oPEpeHpXhYjfrWIv8AkDZ6/fbNuQAO7IAErYAFeXPdl0JaadNU+IWYmMgTadp0wAjpGM8Wrmkv1SGLheU6WJDES9YPT5nMEpu4mMcgBri4r0+DsrNMAAQAAABbSqhvS6dwsRaQHV6ariAjY1eraXBWa1CtJSb4ruSAt8YCsJ4al+ZGUo1sjLK/oyQEXPynJuGeEfROpPrp9CHV6Nvmga3HLonfvsmGssABWQqME1rOMed/YZVvx+f2MaS2NPkRqq5lrgkv4kXyv7GRq9U2uDowAvxC/wAur15X2IACTNgAKgAACdO6T4M6Q8ucvbvDjW2Ecz+bOYIt9NxFFTeRuUfRyVPpbASjW19O4C0wAFZAAAAAAAAAAAAAAAAanGtj69jbhuy69iQSmrlVw3ZdewuG7Lr2JAouWtxrRNc2YAVMtcJRWqa5owAAAAgAAAAAA6wlgKKz4eJKXq44iS6ZWbKfh3F5cLFUq0bxE/8AUzc+FcQAqvXRGkAVUN6XTuKhvS6dyW1UpBVQ3pdO5sPKUlnzyj6qNJ9dRZtlAPav2bb/AJqv8Tz4j8O5exHEjGv6pJv6GY1X0u325AOr00XEG2AAAHtdbAa1Gtr6dzAswAAIAAAAAACdO/qV5k96XULFdpKjke21xvsSARNKcY3pJJcb+wMSjWrafIEaz1DAAVgHoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB//9k="
}