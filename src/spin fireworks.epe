{
  "name": "spin fireworks",
  "id": "F3hxTrC2TttF8rEkb",
  "sources": {
    "main": "/* Also mapped. 12 * 144 of SK9822 wired in setions as:\n        0\n     5     x\n   x         1\n  4           x\n   x         2\n    3      x\n        x\n*/\n\nvar arms = 12\nvar pixPerArm = pixelCount / arms\nradials = array(arms)\nfor (i = 0; i < arms; i ++) { radials[i] = array(pixPerArm) } \n\n// Arm remap array -> takes physical segment in index order (wired order)\n// and returns the index of segment where 0 is the straight up arm (12 oo clock)\n// and proceeds clockwise. aRa[chunk] = clockPositionHour\nvar aRa = array(arms);\naRa[0] = 0; aRa[1] = 6; aRa[2] = 2; aRa[3] = 8;\naRa[4] = 4; aRa[5] = 10; aRa[6] = 7; aRa[7] = 1; \naRa[8] = 9; aRa[9] = 3; aRa[10] = 11; aRa[11] = 5; \nfunction indexToRadial(index) {\n  segment = floor(index / pixPerArm)\n  return aRa[segment]\n}\n\n// 0, 1/12, 2/12, ..etc.. 11/12 \nfunction indexToUnitRadial(index) {\n  return indexToRadial(index) / arms\n}\n\n// Takes an index, returns the fraction of an arm's length from center\nfunction indexToUnit(index) {\n  arm = floor(index / pixPerArm)\n  inbound = (arm % 2) == 0\n  pixIntoArm = index % pixPerArm\n  pixFromCenter = inbound ? (pixPerArm - pixIntoArm - 1) : pixIntoArm\n  return pixFromCenter / pixPerArm\n}\n\n// Takes an index, returns # pixels from center\nfunction indexFromCenter(index) {\n  arm = floor(index / pixPerArm)\n  inbound = (arm % 2) == 0\n  pixIntoArm = index % pixPerArm\n  pixFromCenter = inbound ? (pixPerArm - pixIntoArm - 1) : pixIntoArm\n  return pixFromCenter\n}\n\nvar radialIndex = array(pixelCount)\nfor (i = 0; i < pixelCount; i++) { radialIndex[i] = indexFromCenter(i) }\n\n\n// Takes an index, returns a fraction of an arm's length from center\nfunction indexToUnit(index) {\n  return radialIndex[index] / pixPerArm\n}\n\nvar radialPct = array(pixelCount)\nfor (i = 0; i < pixelCount; i++) { radialPct[i] = indexToUnit(i) }\n\n\nvar t1Override\nexport function slidert1Override(v) { t1Override = v }\nvar modeOverride\nexport function sliderModeOverride(v) { modeOverride = floor(v * numModes * 0.999) }\nvar dmOverride\nexport function sliderDMOverride(v) { dmOverride = floor(v * numDecayModes) }\n\nvar numModes = 8\nvar modeSetup = array(numModes)\nvar beforeRenders = array(numModes)\nvar hFns = array(numModes)\nvar sFns = array(numModes)\nvar vFns = array(numModes)\n\n\ncolorBox = array(4)\n\n\nvar t1, linearT1, dMode = 0\nvar speed, thisModePeriod = 1, thisModeMs = 0\nvar width1 = 5, c1 = 0, sparkle1 = 0\nexport var mode = 0\nexport var w, w1, w2\nexport function beforeRender(delta) {\n  thisModeMs += delta\n  t1 = thisModeMs / (thisModePeriod * 1000)\n\n  if (t1 >= 1) { newMode() }\n  // t1 = t1Override\n  // dMode = dmOverride\n  linearT1 = t1\n  t1 = decayModes[dMode](t1)\n  et1 = 2 * t1 - 0.5 // \"Extended\" t1 - helps create smooth ends and space between modes\n  beforeRenders[mode](delta)\n}\n\nfunction newMode() {\n  mode = floor(random(numModes))\n  if (modeOverride > 0) { mode = modeOverride } // Mode slider leftmost == auto\n  dMode =  floor(random(numDecayModes))\n  thisModeMs = 0\n  t1 = 0\n  thisModePeriod = 1 + random(10)\n  \n  modeSetup[mode]()\n}\n\nexport function render(index) {\n  pct = radialPct[index]\n  h = hFns[mode](index)\n  s = sFns[mode](index)\n  v = vFns[mode](index)\n  hsv(h, s, v*pct)\n}\n\n\nvar numDecayModes = 3\nvar decayModes = array(numDecayModes)\ndecayModes[0] = (u) => { return 1 - (1/pow((1 + u), 5)) } // Power\ndecayModes[1] = (u) => { return 1 - exp(-3 * u) } // Exponential\ndecayModes[2] = (u) => { return u } // Linear\n\n\n// The actual modes\n\nmodeSetup[0] = () => { }\nbeforeRenders[0] = (delta) => { }\nhFns[0] = (index) => { return t1 + index/pixelCount }\nsFns[0] = (index) => { return 1 }\nvFns[0] = (index) => { return abs(indexToUnit(index) - t1) < 1 / (pixelCount / arms) }\n\n\nmodeSetup[1] = () => { \n  c1 = random(0.03) - 0.01\n  width1 = random(1) // 0..1 units, applied to pixPerArm\n  sparkle1 = floor(random(2))\n}\nbeforeRenders[1] = (delta) => { }\nhFns[1] = (index) => { return c1 }\nsFns[1] = (index) => { return 1 }\nvFns[1] = (index) => { \n  v = 1 - abs(et1 - indexToUnit(index)) / width1\n  v = clamp(v, 0, 1)\n  if (sparkle1 && random(t1) > 0.5) v = 0\n  return v * v\n}\n\n\nmodeSetup[2] = () => { thisModePeriod = 1 + random(3) }\nbeforeRenders[2] = (delta) => { }\nhFns[2] = (index) => { return 0 }\nsFns[2] = (index) => { return 0 }\nvFns[2] = (index) => { return t1 < 0.33 ? square(t1*30,1-3*t1) : 0 }\n\n\nvar gamma1 = 1\nmodeSetup[3] = () => { gamma1 = 1 + floor(random(6)) }\nbeforeRenders[3] = (delta) => { }\nhFns[3] = (index) => { return t1 + index/pixelCount }\nsFns[3] = (index) => { return 1 }\nvFns[3] = (index) => { v = triangle(t1); return pow(v, gamma1) }\n\n\n// Peony\nmodeSetup[4] = () => { \n  colorBox[0] = 0\n  colorBox[1] = 0.02\n  colorBox[2] = 0.7\n  colorBox[3] = random(1)\n  color1 = colorBox[floor(random(4))]\n}\nbeforeRenders[4] = (delta) => { }\nhFns[4] = (index) => { return color1 + random(0.02) }\nsFns[4] = (index) => { return (random(1) < (2 * t1 - 1) && random(1) < 0.02) ? 0 : 1 }\nvFns[4] = (index) => { \n  fadeEnd = clamp(-1/(0.2)*(linearT1-0.8) + 1,0,1);\n  return fadeEnd * (indexToUnit(index) < (t1*1.2)) }\n\n\n// Fill whole strip linearly\nvar startingOffset = 0\nmodeSetup[5] = () => { \n  colorBox[0] = 0.33\n  colorBox[1] = 0.13\n  colorBox[2] = 0.66\n  colorBox[3] = 0.96\n  color1 = colorBox[floor(random(4))]\n  startingOffset = floor(random(pixelCount))\n}\nbeforeRenders[5] = (delta) => { }\nhFns[5] = (index) => { return color1 + random(0.02) }\nsFns[5] = (index) => { return sqrt((t1)) }\nvFns[5] = (index) => { \n  progressOutwards = ((index + startingOffset ) % pixelCount)/pixelCount < t1\n  fadeEnd = clamp(-1/(0.2)*(linearT1-0.8) + 1,0,1)\n  return progressOutwards * fadeEnd\n}\n\n\n// Radials on delays\nmodeSetup[6] = () => { width1 = 0.3 }\nbeforeRenders[6] = (delta) => { }\nhFns[6] = (index) => { return color1 + t1 + indexToUnitRadial(index) }\nsFns[6] = (index) => { return 1 }\nvFns[6] = (index) => { \n  v = 1 - abs(et1 - indexToUnitRadial(index) - indexToUnit(index)) / width1\n  v = clamp(v, 0, 1)\n  fadeEnd = clamp(-1/(0.2)*(linearT1-0.8) + 1,0,1)\n  v *= fadeEnd\n  return v\n}\n\n\n// Wave phase offsets\nexport var colorMode = 0\nmodeSetup[7] = () => {\n  colorMode = floor(random(4))\n  width1 = random(30)\n  colorBox[0] = (i) => { return indexToUnitRadial(i) }\n  colorBox[1] = (i) => { return 0.2 * i/pixelCount }\n  colorBox[2] = (i) => { return 0 }\n  colorBox[3] = (i) => { return 0 + random(0.02) }\n}\nbeforeRenders[7] = (delta) => { }\nhFns[7] = (index) => { return colorBox[colorMode](index) }\nsFns[7] = (index) => { return 1 }\nvFns[7] = (index) => { \n  pos = indexToUnit(index)\n  radial = indexToUnitRadial(index)\n  v = triangle((pos - t1 + linearT1)*4) * triangle(pos - t1 * (width1 - 4))\n  v = clamp(v, 0, 1)\n  \n  fadeEnd = clamp(-1/(0.2)*(linearT1-0.8) + 1,0,1)\n  v *= fadeEnd\n  return v * v\n}\n\n"
  },
  "preview": "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"
}